# The third study note
### 10月22日
知道了socket的基本定义(网络连接端点)，socket以ip地址和端口数来区分，在服务器端和客户端各有一个socket来进行数据的接收、发送和监听。本次学习主要使用TCP和UDP协议，TCP稳定定向，UDP快速但不可靠。

### 10月23日
* 首先先学习基本的新手教程，全程使用python的socket模块。在创建socket前必须知道本机的IP地址和主机名。在非python程序中IP地址多用32位字节包储存。
* 创建socket，输入给定的相关参数，可选项proto可指定所用协议。fromfd可以文件描述符的形式创建socket。shutdown命令可任意关闭接收或发送端
* 打开两个命令提示符，分别创建socket来代表服务器端和客户端，服务器端以bind绑定地址和端口，客户端以connect连接服务器端。服务器端以accept结束时会进入等待连接的状态，无法输入内容，这并非程序无法响应的结果
* 服务器端以send发送数据，发送时无法直接在send语句中输入，因为python3时bytes-like的，str类型的无法直接发送，需在字符串前面加上‘b’解决问题。若用UDP协议需用sendto语句定向发送至特定地址，发送后会返回发送的字节
* 客户端以recv接收，接收后的数据会从列表中删除，可使用MSG_PEEK来防止删除。使用recvfrom可在family为AF_INET时同时返回数据及其来源
* getpeername和getsockname可分别返回远程和本地地址和端口。socket默认为阻塞状态，调用setblocking（0）可转为非阻塞状态
* 传输数据应使用网络标准的字节顺序，应将本机字节顺序进行转换

### 10月27日
* 学会使用socketservers，主要使用它的两个子类‘TCPServer，UDPServer’（大小写一点都不能错。。。），它们可以以AF_UNIX来代替AF_INET。
* 可以用serve_forever和handle_request来进行线程处理，区别是后者只能一个一个处理，前者相当于同时调用多个后者。
* 利用BaseRequestHandler的_init_来请求处理器，setup来初始化，handle服务于请求，finish用于清理，前两者出错会取消finish的调用。
* 创建服务器（1）根据通讯的功能确定使用具有不同功能的BaseRequestHandler子类和用于覆盖它的handle（）方法来请求服务器类（利用class来定义一个类）
 （2）实例化服务类，server=TCPserver（地址，端口）
 （3）调用serve_forever或handle_request来处理请求
* 上述为socket的阻塞和同步编程，只能同时连接一个客户端，若要同时连接多个客户端，则需进行socket的非阻塞或异步处理。使用forking或threading的方法，在用class定义socket类之前加上“class Server(ForkingMixIn,TCPServer):Pass”,在后面实例化服务类时以Server来替代原本的TCPServer，私下认为该语句起到用来修饰TCPServer的作用。
但forking只能用于类unix系统，threading存在内存共享需要注意的问题，因此这两种方法存在局限性。

### 10月28日
* 使用select模块可以实现更加优异的异步I/O，select需要输入三个序列（输入，输出，异常条件）和一个超时值，在每个超时值内容许一个客户端socket进行连接。使用select实现异步需要使用循环语句，每个连接的socket存入到以list形式存在的输入序列中（包含服务端本身），在断开连接时又自动从序列中剔除，从而达到轮流连接多个socket的目的。（实现起来还是比较复杂的）
* 使用urllib模块可以打开或者获取远程文件，使用urlopen函数可以将标识符与网站或者本地路径相连接，利用re等其他模块便可以实现注入提取网站URL的操作
* urlopen本身会返回一个文件类对象，可以将其储存至本地地址，储存时应设置好文件的名称与类型，若不提供地址可以利用open函数将储存至临时地点的文件打开。

### 10月29日
* 今天开始正式做任务，打听了才知道只要实现客户端与服务端的简单通信交流即可，这是最基本的功能，第一课便可以实现，所以我打算在此基础上实现更多功能。
* 实现socket的异步看似简单实则十分曲折，使用网上提供的threading教程和select模块教程都存在一定的问题，而且究其作用也不过是实现一个socket的断开后进行下一个socket的连接，再看了这些有问题的教程后我发现：可以使用while的循环功能便实现异步化。
* 在accept之前进行循环以实现一个socket断开后的自动连接
* 在accept后进行循环以实现两端之间的持续交流
* 设置固定的字符串，发送时可以主动断开连接，若断开后无后续socket接入，服务端会卡住，若直接关闭客户端的窗口，循环会直接结束(原因不明)
* 因为是自己设计功能所以socketserver以及BaseRequestHandler暂时不会用到

### 10月30日
* 若无任何循环语句，客户端和服务端连接后是可以自由地相互发送接收信息的，可加入循环语句后服务端便失去了自由输入的功能，只能像个傻子一样等待信息的接收，因此我想实现这种状况下的服务端输入功能
* 由于运行程序处于循环中，因此无法像单接一个客户端时随意输入send或recv进行操作，应将这些语句置于更内层的循环中，使用者需等待其自动读取到相应位置进行操作
* 直接使用send语句无法达成目标，需要以input语句给变量m赋值，将m导入到send中才能进行信息的发送
* 由于python3是bytes-like的，因此直接在send中输入想要发送的字符串无法发送，要转为b'xxx'的形式，可如何将m转为这种形式呢，我一开始的想法是直接外套一层b''的壳，可这样下来m将被视作字符常量'm'处理，无论是在send的()里面还是input外面外套都是如此
* 在网上查阅后，我发现了一个其实在python第一章便已介绍过的方法---拼接法，将b'和m和'三部分加在一起就可以在理论上组成我需要的b'm'，可这样输出的实际结果与期望结果总是不同，经查找原因在于'字符的特殊性，如不转义（\）单独的'不会被视为'字符
* 即便是顺利完成拼接，也无法顺利输入，原因在于拼接后的结果是"b'm'"（str）而非b'm'（bytes-like），因此还需另寻他径
* 最后还是使用了格式转换的方法，利用bytes(xxx,encoding = "utf8")将需要输入的字符直接转为bytes
* 在运行时发现每次能够正常进行输入之前循环总会自动运行几次，经观察代码发现代码最后有几行空行，在进行循环时输入因为代码末尾空行的存在使得输入流中存在多个回车，它们赋给了最初的几个m，因此自动循环几次
* 接收的信息中如还有中文需要使用decode解码，运用encode和decode可以顺利实现信息的传递，并且隐藏bytes自带的b' '框

### 10月31日
* 最后在服务端实现保存数据的功能，使用open函数可以选定已有文件或者创建文件，并决定打开的方式
* write函数可以将数据写入选定文件中，写入位置由open的相关参数决定，使用read进行读操作，在过程中我发现只有使用close关闭open才能显示出在此过程中新加入的信息，因此在每个循环中都开启并关闭一次来保证数据能写入
* 如要在命令行模式中直接打开py文件，则需要将语句都置于循环结构中自动运行才能正常输入接收